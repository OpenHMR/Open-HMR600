/******************************************************************************
* recv_linux.c                                                                                                                                 *
*                                                                                                                                          *
* Description :                                                                                                                       *
*                                                                                                                                           *
* Author :                                                                                                                       *
*                                                                                                                                         *
* History :                                                          
*
*                                        
*                                                                                                                                       *
* Copyright 2007, Realtek Corp.                                                                                                  *
*                                                                                                                                        *
* The contents of this file is the sole property of Realtek Corp.  It can not be                                     *
* be used, copied or modified without written permission from Realtek Corp.                                         *
*                                                                                                                                          *
*******************************************************************************/
#define _RECV_OSDEP_C_

#include <drv_conf.h>
#include <osdep_service.h>
#include <drv_types.h>

#include <wifi.h>
//#include <rtl8711_regdef.h>
#include <recv_osdep.h>

#include <osdep_intf.h>
#include <Ethernet.h>

#include <usb_ops.h>
#include <rtl8187/wlan.h>


#ifdef PLATFORM_WINDOWS

#error "PLATFORM_WINDOWS should not be defined!\n"

#endif

#ifdef CONFIG_RTL8187
extern void mgtctrl_dispatchers(_adapter *adapter, union recv_frame *precv_frame);
#endif

//recv_osdep.c
void	_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv)
{
	sint i;
_func_enter_;	
	memset((u8 *)psta_recvpriv, 0, sizeof (struct sta_recv_priv));

	_spinlock_init(&psta_recvpriv->lock);

	for(i=0; i<MAX_RX_NUMBLKS; i++)
		_init_queue(&psta_recvpriv->blk_strms[i]);

	_init_queue(&psta_recvpriv->defrag_q);
_func_exit_;

}

sint	_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter)
{
	sint i;
	union recv_frame *precvframe;
//	NDIS_STATUS	 status;
	sint	res=_SUCCESS;
_func_enter_;		
	memset((unsigned char *)precvpriv, 0, sizeof (struct  recv_priv));

	_spinlock_init(&precvpriv->lock);
	_init_sema(&precvpriv->recv_sema, 0);
	_init_sema(&precvpriv->terminate_recvthread_sema, 0);
#if 0   //need to modified
	 NdisInitializeEvent(&precvpriv->recv_resource_evt);
#endif
	 precvpriv->counter=1;

	for(i=0; i<MAX_RX_NUMBLKS; i++)
		_init_queue(&precvpriv->blk_strms[i]);


	_init_queue(&precvpriv->free_recv_queue);
	_init_queue(&precvpriv->recv_pending_queue);	


	/*
	remember: 2048 aligned
	
	Please allocate memory with the sz = (struct recv_frame) * NR_recvFRAME, 
	and initialize free_recv_frame below.
	Please also link_up all the recv_frames...
	*/

	precvpriv->pallocated_frame_buf = _malloc(NR_RECVFRAME * sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);
	if(precvpriv->pallocated_frame_buf==NULL){
		res= _FAIL;
		goto exit;
	}
	memset(precvpriv->pallocated_frame_buf, 0, NR_RECVFRAME * sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);

	precvpriv->precv_frame_buf = precvpriv->pallocated_frame_buf + RXFRAME_ALIGN_SZ -
							((uint) (precvpriv->pallocated_frame_buf) &(RXFRAME_ALIGN_SZ-1));

	precvframe = (union recv_frame*) precvpriv->precv_frame_buf;

	for(i=0; i < NR_RECVFRAME ; i++)
	{
		_init_listhead(&(precvframe->u.list));

		//list_insert_tail(&(precvframe->u.list), &(precvpriv->free_recv_queue.queue));
		precvframe->u.hdr.adapter =padapter;
#ifdef CONFIG_USB_HCI
		//precvframe->u.hdr.purb=usb_alloc_urb(0,GFP_ATOMIC);
		precvframe->u.hdr.purb=usb_alloc_urb(0,GFP_KERNEL);
#endif
		precvframe->u.hdr.pkt = alloc_skb(2048,GFP_ATOMIC);
		precvframe->u.hdr.fragcnt=0;
		precvframe++;
	}
	precvpriv->RxPktPoolHdl = NULL;
	precvpriv->RxBufPoolHdl = NULL;
	precvpriv->adapter = padapter;

#ifdef CONFIG_RTL8187
	
	precvpriv->prxirp =(struct rxirp *) _malloc( sizeof(struct rxirp) );
	if(precvpriv->prxirp==NULL){
		res = _FAIL;
		goto exit;
	}
	memset(precvpriv->prxirp, 0, sizeof(struct rxirp));
	precvpriv->prxirp->adapter = padapter;

#endif
	
exit:	
_func_exit_;
	return _TRUE;
	

}

/*
caller of _free_recv_priv have to make sure " NO ONE WILL ACCESS recv_priv "
=>>>>>>down(terminate_recvthread_sema) is true
*/
void _free_recv_priv (struct recv_priv *precvpriv)
{
	uint i;
	union recv_frame *precvframe;
_func_enter_;		
	precvframe = (union recv_frame*) precvpriv->precv_frame_buf;


	for(i=0; i < NR_RECVFRAME ; i++)
	{ 
		// free NdisFreeBuffer
		//NdisFreePacket(precvframe->u.hdr.pkt);
		if(precvframe->u.hdr.pkt !=NULL)
			kfree_skb(precvframe->u.hdr.pkt);
#ifdef CONFIG_USB_HCI
		if(precvframe->u.hdr.purb !=NULL){
			usb_kill_urb(precvframe->u.hdr.purb);
			usb_free_urb(precvframe->u.hdr.purb);
		}
#endif
		precvframe++;	
	}
	if(precvpriv->RxBufPoolHdl != NULL)
		DEBUG_ERR(("\n precvpriv->RxBufPoolHdl != NULL , something rwrong!!! \n"));

	if(precvpriv->RxPktPoolHdl != NULL)
		DEBUG_ERR(("\n precvpriv->RxPktPoolHdl != NULL , something rwrong!!! \n"));

	if(precvpriv->pallocated_frame_buf)
		_mfree(precvpriv->pallocated_frame_buf, NR_RECVFRAME * sizeof(union recv_frame)+RXFRAME_ALIGN_SZ );

_func_exit_;
}


sint recvframe_chkmic(_adapter *adapter,  union recv_frame *precvframe){

	sint 			i;
	u32	datalen;
	u8 miccode[8];
	u8	*pframe, *payload,*pframemic;
	struct	sta_info		*stainfo;

	struct	rx_pkt_attrib	*prxattrib=&precvframe->u.hdr.attrib;
//	struct 	security_priv	*psecuritypriv=&adapter->securitypriv;

_func_enter_;	
	
	stainfo=get_stainfo(&adapter->stapriv ,&prxattrib->ta[0] );

	if(prxattrib->encrypt ==_TKIP_){
		//calculate mic code
		if(stainfo!= NULL){
			datalen=precvframe->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len-prxattrib->icv_len-8;//icv_len included the mic code
			pframe=precvframe->u.hdr.rx_data;
			payload=pframe+prxattrib->hdrlen+prxattrib->iv_len;
			
			seccalctkipmic(&stainfo->dot11tkiprxmickey.skey[0],pframe,payload, datalen ,&miccode[0], (unsigned char)prxattrib->priority ); //care the length of the data
			pframemic=payload+datalen;
			for(i=0;i<8;i++){
				if(miccode[i] != *(pframemic+i))
					DEBUG_ERR(("recvframe_chkmic:miccode[%d] != *(pframemic+%d) ",i,i));
			}
			recvframe_pull_tail(precvframe, 8);	
		}
		else{
			DEBUG_ERR(("recvframe_chkmic: get_stainfo==NULL!!!\n"));
		}
	}
	
_func_exit_;
	return _SUCCESS;
}


//perform new defrag method, thomas 1202-07
union recv_frame * recvframe_defrag_new(_adapter *adapter,_queue *defrag_q,union recv_frame* precv_frame)
{
	_list	 *plist, *phead;	
	u8	wlanhdr_offset;
	struct recv_frame_hdr *pfhdr,*pnfhdr;
	union recv_frame* prframe,*prtnframe;

_func_enter_;		

	if( _queue_empty(defrag_q) == _FALSE ){

		phead = get_list_head(defrag_q);
		plist = get_next(phead);
		prframe = LIST_CONTAINOR(plist, union recv_frame, u);

		pfhdr=&prframe->u.hdr;
		pnfhdr=&precv_frame->u.hdr;
	
		//3 check the fragment sequence  (2nd ~n fragment frame)
		if(pfhdr->fragcnt != pnfhdr->attrib.frag_num) {
			//if miss 1 of the fragment
			//free the whole queue
			DEBUG_ERR(("Fragment number is wrong!!!,fragcnt = %d, frag_num = %d\n",pfhdr->fragcnt, pnfhdr->attrib.frag_num));
			pfhdr->fragcnt = 0;
			return NULL;
		}
	
		//3 copy the 2nd~n fragment frame's payload to the first fragment
		
		//get the 2nd~last fragment frame's payload
		
		wlanhdr_offset=pnfhdr->attrib.hdrlen+pnfhdr->attrib.iv_len;

		recvframe_pull(precv_frame, wlanhdr_offset);
			
		//append  to first fragment frame's tail (if privacy frame, pull the ICV)
		recvframe_pull_tail(prframe,pfhdr->attrib.icv_len);

		//memcpy
		_memcpy(pfhdr->rx_tail, pnfhdr->rx_data, pnfhdr->len);
		
		recvframe_put(prframe, pnfhdr->len);
		
		pfhdr->attrib.icv_len=pnfhdr->attrib.icv_len;	

		DEBUG_INFO(("Performance %d defrag!!!!!\n",pfhdr->fragcnt));

		if( pnfhdr->attrib.mfrag == 0) {
			list_delete(&prframe->u.hdr.list);
			pfhdr->attrib.mfrag = 0;
			pfhdr->fragcnt = 0;
			prtnframe = prframe;
		}
		else {
			prtnframe = precv_frame;
			pfhdr->fragcnt++;
		}

_func_exit_;	
		return prtnframe;

	}
	else {
		//defrag_q is empty
_func_exit_;
		DEBUG_ERR(("Missing frist fragment. Defrag queue is empty!!!!\n"));
		return NULL;
	}

}  

//check if need to defrag, if needed queue the first frame to defrag_q, and copy 2~n frame's payload to first frame
union recv_frame * recvframe_chk_defrag_new(_adapter *padapter,union recv_frame* precv_frame)
{
//	unsigned long flags;
	u8	ismfrag;
	u8	fragnum;
	u8   *psta_addr;
	struct recv_frame_hdr *pfhdr;
	struct sta_info * psta;
	struct	sta_priv *pstapriv ;
	_list	 *phead,*plist;
	union recv_frame* prtnframe = NULL,*pfreeframe = NULL;
	_queue	 *pdefrag_q;
	struct intf_hdl * pintfhdl=&padapter->pio_queue->intf;
//	sint ret = _SUCCESS;

_func_enter_;		
	pstapriv = &padapter->stapriv;

	pfhdr=&precv_frame->u.hdr;

	//need to define struct of wlan header frame ctrl
	ismfrag= pfhdr->attrib.mfrag;
	fragnum=pfhdr->attrib.frag_num;
	
	psta_addr=pfhdr->attrib.ta;
	psta=get_stainfo(pstapriv, psta_addr);
	if(psta==NULL)
		pdefrag_q=NULL;
	else	
		pdefrag_q=&psta->sta_recvpriv.defrag_q;

	if((ismfrag==0)&&(fragnum==0)) {
		//isn't a fragment frame
		prtnframe = precv_frame;
		recvframe_chkmic(padapter,  prtnframe);
	}
	else if(pdefrag_q != NULL) {
		if(ismfrag==1){
			// 1~(n-1) fragment frame
			//copy payload to first pkt
			if(fragnum==0) 
			{	//the first fragment
				if(_queue_empty(pdefrag_q) == _FALSE) {
					//free current defrag_q
					DEBUG_ERR(("Another first fragment packet, free defrag_q \n"));
					phead = get_list_head(pdefrag_q);
					plist = get_next(phead);
					pfreeframe = LIST_CONTAINOR(plist, union recv_frame, u);
					list_delete(&pfreeframe->u.hdr.list);
					pfreeframe->u.hdr.fragcnt = 0;
					usb_read_port(pintfhdl, 0, 0, (unsigned char *)pfreeframe);
				}

				//Then enqueue the first fragment in the defrag_q
				phead = get_list_head(pdefrag_q);
				list_insert_tail(&pfhdr->list,phead);
				pfhdr->fragcnt ++;

				DEBUG_INFO(("Enqueu first fragment to defrag_q \n"));
				prtnframe = NULL;
			}
			else 
			{	//  2nd~(n-1) fragment
				prtnframe = recvframe_defrag_new(padapter,pdefrag_q,precv_frame);
				if( prtnframe == NULL ) {
					prtnframe = precv_frame;
				}
			}
		}  
		else if((ismfrag==0)&&(fragnum!=0)){
			//the last fragment frame
			prtnframe = recvframe_defrag_new(padapter,pdefrag_q,precv_frame);
			if( prtnframe == NULL ) {
				
				precv_frame->u.hdr.attrib.mfrag = 1;
				
				if(_queue_empty(pdefrag_q) == _FALSE) {
					//defrag queue is not empty, dequeue the first recv frame, and submit it
					DEBUG_INFO(("Frag_num is wrong, free defrag_q \n"));
					phead = get_list_head(pdefrag_q);
					plist = get_next(phead);
					pfreeframe = LIST_CONTAINOR(plist, union recv_frame, u);
					list_delete(&pfreeframe->u.hdr.list);
					usb_read_port(pintfhdl, 0, 0, (unsigned char *)pfreeframe);
					prtnframe = precv_frame;
				}
				else 
					prtnframe = precv_frame;

			}
			else {
				DEBUG_INFO(("Fragment complete \n"));
				recvframe_chkmic(padapter,  prtnframe);
				usb_read_port(pintfhdl, 0, 0, (unsigned char *)precv_frame);
			}
		}
	}
	else {
		prtnframe = precv_frame;
		DEBUG_ERR(("Can not  find this ta's defrag_queue\n"));
	}

_func_exit_;
	return prtnframe;

}


//perform defrag
union recv_frame * recvframe_defrag(_adapter *adapter,_queue *defrag_q)
{


	_list	 *plist, *phead;	
	u8	*data,wlanhdr_offset;
	u8   curfragnum;
	struct recv_frame_hdr *pfhdr,*pnfhdr;
	union recv_frame* prframe, *pnextrframe;
	_queue	*pfree_recv_queue;

_func_enter_;		
	curfragnum=0;
	pfree_recv_queue=&adapter->recvpriv.free_recv_queue;

	phead = get_list_head(defrag_q);			
	plist = get_next(phead);
	
	prframe = LIST_CONTAINOR(plist, union recv_frame, u);

	pfhdr=&prframe->u.hdr;
	list_delete(&(prframe->u.list));

	if(curfragnum!=pfhdr->attrib.frag_num) {
		//the first fragment number must be 0
		//free the whole queue
		 free_recvframe_queue(defrag_q, pfree_recv_queue);  
		return NULL;
	}
	curfragnum++;
	
	plist= get_list_head(defrag_q);

	plist = get_next(plist);

	data=get_recvframe_data(prframe);

	while(end_of_queue_search(phead, plist) == _FALSE){		
			
		pnextrframe = LIST_CONTAINOR(plist, union recv_frame , u);
		pnfhdr=&pnextrframe->u.hdr;
		//4 check the fragment sequence  (2ed ~n fragment frame)
		
		if(curfragnum!=pnfhdr->attrib.frag_num){
			//the fragment number must be increasing  (after decache) 
			//3 release the defrag_q & prframe
			free_recvframe(prframe, pfree_recv_queue);  
			free_recvframe_queue(defrag_q, pfree_recv_queue);  
			return NULL;
		}
		curfragnum++;

		//3 copy the 2nd~n fragment frame's payload to the first fragment
		
		//get the 2nd~last fragment frame's payload
		
		wlanhdr_offset=pnfhdr->attrib.hdrlen+pnfhdr->attrib.iv_len;

		recvframe_pull(pnextrframe, wlanhdr_offset);
			
		//append  to first fragment frame's tail (if privacy frame, pull the ICV)
		recvframe_pull_tail(prframe,pfhdr->attrib.icv_len);

		//memcpy
		_memcpy(pfhdr->rx_tail, pnfhdr->rx_data, pnfhdr->len);
		
		recvframe_put(prframe, pnfhdr->len);
		
		pfhdr->attrib.icv_len=pnfhdr->attrib.icv_len;
		plist = get_next(plist);
				
	};

	//free the defrag_q queue and return the prframe
	free_recvframe_queue(defrag_q, pfree_recv_queue);  
	DEBUG_INFO(("Performance defrag!!!!!\n"));
_func_exit_;	
	return prframe;

}  

//check if need to defrag, if needed queue the frame to defrag_q
union recv_frame * recvframe_chk_defrag(_adapter *padapter,union recv_frame* precv_frame)
{
	u8	ismfrag;
	u8	fragnum;
	u8   *psta_addr;
	struct recv_frame_hdr *pfhdr;
	struct sta_info * psta;
	struct	sta_priv *pstapriv ;
	_list	 *phead;
	union recv_frame* prtnframe = NULL;
	_queue	 *pfree_recv_queue, *pdefrag_q;

_func_enter_;		
	pstapriv = &padapter->stapriv;

	pfhdr=&precv_frame->u.hdr;
	
	pfree_recv_queue=&padapter->recvpriv.free_recv_queue;

	//need to define struct of wlan header frame ctrl
	ismfrag= pfhdr->attrib.mfrag;
	fragnum=pfhdr->attrib.frag_num;
	
	psta_addr=pfhdr->attrib.ta;
	psta=get_stainfo(pstapriv, psta_addr);
	if(psta==NULL)
		pdefrag_q=NULL;
	else	
		pdefrag_q=&psta->sta_recvpriv.defrag_q;

	if((ismfrag==0)&&(fragnum==0))
		//isn't a fragment frame
		prtnframe=precv_frame;
	
	if(ismfrag==1){
		// 0~(n-1) fragment frame
		//enqueue
	  if(pdefrag_q != NULL){
		
		if(fragnum==0){
			//the first fragment
			
				//if(_queue_empty(&psta->sta_recvpriv.defrag_q) == _FALSE)
			if(_queue_empty(pdefrag_q) == _FALSE)
				//free current defrag_q
				free_recvframe_queue(pdefrag_q,pfree_recv_queue ); 

		
		}
		//Then enqueue the first fragment in the defrag_q
			//spinlock
			_spinlock(&pdefrag_q->lock);
			phead = get_list_head(pdefrag_q);
			list_insert_tail(&pfhdr->list,phead);
			//unlock
			_spinunlock(&pdefrag_q->lock);
			DEBUG_INFO(("Enqueuq: ismfrag = %d, fragnum= %d\n", ismfrag,fragnum));
		prtnframe=NULL;
	}
	else{
		//can't find this ta's defrag_queue, so free this recv_frame 
		free_recvframe(precv_frame,pfree_recv_queue);
		prtnframe=NULL;
		DEBUG_ERR(("Free because pdefrag_q ==NULL: ismfrag = %d, fragnum= %d\n", ismfrag,fragnum));
		}
	}  
	if((ismfrag==0)&&(fragnum!=0)){
		//the last fragment frame
		//enqueue the last fragment
		if(pdefrag_q != NULL){
			//spinlock
			_spinlock(&pdefrag_q->lock);
			phead = get_list_head(pdefrag_q);
			list_insert_tail(&pfhdr->list,phead);
			_spinunlock(&pdefrag_q->lock);
			//unlock
		
			//call recvframe_defrag to defrag
			DEBUG_INFO(("defrag: ismfrag = %d, fragnum= %d\n", ismfrag,fragnum));
			precv_frame=recvframe_defrag(padapter,pdefrag_q);
			prtnframe=precv_frame;
		
		}
		else{
			//can't find this ta's defrag_queue, so free this recv_frame 
			free_recvframe(precv_frame,pfree_recv_queue);
			prtnframe=NULL;
			DEBUG_ERR(("Free because pdefrag_q ==NULL: ismfrag = %d, fragnum= %d\n", ismfrag,fragnum));
		}
	}
	if(prtnframe!=NULL)
		//after defrag we must check tkip mic code 
		recvframe_chkmic(padapter,  prtnframe);
_func_exit_;		
	return prtnframe;
}



//decrypt and set the ivlen,icvlen of the recv_frame
union recv_frame * decryptor(_adapter *padapter,union recv_frame * precv_frame)
{

	struct	rx_pkt_attrib	 *prxattrib = &precv_frame->u.hdr.attrib;
	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
#ifdef CONFIG_RTL8187
	struct rx_desc_rtl8187b * prxstat = (struct rx_desc_rtl8187b *)(precv_frame->u.hdr.rx_tail+4);
#else
	struct 	recv_stat *prxstat=(struct recv_stat *)precv_frame->u.hdr.rx_head;
#endif

_func_enter_;			
	if((prxstat->decrypted==0)&&(prxattrib->encrypt>0)&&(psecuritypriv->sw_decrypt)){

		DEBUG_INFO(("perfrom software decryption! \n"));
		switch(prxattrib->encrypt){
		case _WEP40_:
		case _WEP104_:
			wep_decrypt(padapter, (u8 *)precv_frame);
			break;
		case _TKIP_:
			tkip_decrypt(padapter, (u8 *)precv_frame);
			break;
		case _AES_:
			aes_decrypt(padapter, (u8 * )precv_frame);
			break;
		default:
				break;
		}

	}

	//recvframe_chkmic(adapter, precv_frame);   //move to recvframme_defrag function
_func_exit_;		
	return precv_frame;
}
//###set the security information in the recv_frame
union recv_frame * portctrl(_adapter *adapter,union recv_frame * precv_frame)
{
	u8   *psta_addr,*ptr;
	uint  auth_alg;	
	struct recv_frame_hdr *pfhdr;
	struct sta_info * psta;
	struct	sta_priv *pstapriv ;
#ifdef CONFIG_RTL8187
	struct rx_desc_rtl8187b *prxstat;
#else
	struct recv_stat *prxstat;
#endif
	union recv_frame * prtnframe;
	u16	ether_type=0;
_func_enter_;			
	pstapriv = &adapter->stapriv;
	ptr=get_recvframe_data(precv_frame);
	pfhdr=&precv_frame->u.hdr;
	psta_addr=pfhdr->attrib.ta;
	psta=get_stainfo(pstapriv, psta_addr);
	
	auth_alg=adapter->securitypriv.dot11AuthAlgrthm;

	if(auth_alg==2){
		
	  if((psta!=NULL)&&( psta->ieee8021x_blocked)){
	  	
		//blocked
		//only accept EAPOL frame
		DEBUG_INFO(("########portctrl:psta->ieee8021x_blocked==1\n"));
		
		prtnframe=precv_frame;
		
				//get ether_type
		ptr=ptr+pfhdr->attrib.hdrlen+pfhdr->attrib.iv_len+LLC_HEADER_SIZE;
		 _memcpy(&ether_type,ptr, 2);
		 ether_type= ntohs((unsigned short )ether_type);
		 
		if(ether_type == 0x888e){
			prtnframe=precv_frame;
		}
		else{  //free this frame
#ifdef CONFIG_SDIO_HCI
			free_recvframe(precv_frame, &adapter->recvpriv.free_recv_queue);
#endif
			prtnframe=NULL;
		}			
	  }
	  else{ //allowed
	  	//check decryption status, and decrypt the frame if needed	
	  	DEBUG_INFO(("########portctrl:psta->ieee8021x_blocked==0\n"));
		DEBUG_INFO(("portctrl:precv_frame->u.hdr.attrib.privicy=%x\n",precv_frame->u.hdr.attrib.privacy));
#ifdef CONFIG_RTL8187
		prxstat = (struct rx_desc_rtl8187b *)(precv_frame->u.hdr.rx_tail+4);
#else
		prxstat=(struct recv_stat *)precv_frame->u.hdr.rx_head;
#endif

		if(prxstat->decrypted==0)
		DEBUG_INFO(("portctrl:prxstat->decrypted=%x\n",prxstat->decrypted));

	  	prtnframe=precv_frame;
  		//check is the EAPOL frame or not (Rekey)
		if(ether_type == 0x888e){

			DEBUG_INFO(("########portctrl:ether_type == 0x888e\n"));
			//check Rekey 

			prtnframe=precv_frame;
			
		}
		else{
			DEBUG_INFO(("########portctrl:ether_type != 0x888e\n"));
		}
	  }
	}
	else
		prtnframe=precv_frame;
_func_exit_;	
		return prtnframe;
}
#ifdef CONFIG_HCI_SDIO
u32 blk_read_rxpkt(_adapter *padapter,union recv_frame *precvframe){

	sint rxlen, rxlen_t, remainder;
	struct recv_stat *prxstat;
	struct recv_test *prxtest;//
	u32 pattern = 0xffffffff;
   	uint rx_state = 1;
	u32 ret=_SUCCESS;
	u8 *phead=precvframe->u.hdr.rx_head;
	u8 *pdata=precvframe->u.hdr.rx_data;
	u8 *ptail=precvframe->u.hdr.rx_tail;
	u8 *pend=precvframe->u.hdr.rx_end;   
	struct registry_priv *pregistrypriv = &padapter->registrypriv;
	struct dvobj_priv *pdevobj=&padapter->dvobjpriv;

	
_func_enter_;			   


	if( (padapter->bDriverStopped ==_TRUE) || (padapter->bSurpriseRemoved == _TRUE)){
		ret= _FAIL;
		goto exit;
	}


	read_port(padapter, Host_R_FIFO, 512, phead);
	
       prxstat=(struct recv_stat *)phead;
	prxtest=(struct recv_test *)phead;
   

#ifdef CONFIG_BIG_ENDIAN
prxstat ->frame_length = prxtest->frame_length1+(prxtest->frame_length2<<8);
prxstat->ack_policy = prxtest->ack_policy;
prxstat->addr_hit = prxtest->addr_hit;
prxstat->agc = prxtest->agc;
prxstat->antenna = prxtest->antenna;
prxstat->cfo = prxtest->cfo;
prxstat->crc32 = prxtest->crc32;
prxstat->data = prxtest->data;
prxstat->decrypted = prxtest->decrypted;
prxstat->eosp = prxtest->eosp;
prxstat->fot = prxtest->fot1+(prxtest->fot2<<8);
prxstat->frag = prxtest->frag;
prxstat->icv = prxtest->icv;
prxstat->k_int = prxtest->k_int;
prxstat->mdata = prxtest->mdata;
prxstat->mgt = prxtest->mgt;
prxstat->no_mcsi = prxtest->no_mcsi1+ (prxtest->no_mcsi2<< 2);
prxstat->own = prxtest->own;
prxstat->pwdb = prxtest->pwdb;
prxstat->pwrmgt = prxtest->pwrmgt;
prxstat->qos = prxtest->qos;
prxstat->queue_size = prxtest->queue_size;
prxstat->retx = prxtest->retx;
prxstat->rssi = prxstat->rssi;
prxstat->rxdata = prxstat->rxdata;
prxstat->rxsnr = prxtest->rxsnr;
prxstat->seq = prxtest->seq1 +(prxtest->seq2<<8);
prxstat->splcp = prxtest->splcp;
prxstat->sq = prxtest->sq;
prxstat->tid = prxtest->tid;
prxstat->txmac_id = prxtest->txmac_id;
#endif
	   
       
	 if(_memcmp(pdata,&pattern,4) == _TRUE){
		DEBUG_ERR(("####recv 4 bytes of 0xff pkt"));
		ret = state_no_rx_data;
 	     	goto exit;
	}


	rxlen = prxstat->frame_length;
	
	//notes:update tail before update pdata
	ptail = recvframe_put(precvframe, 16);    
       pdata = recvframe_pull(precvframe, 16);  

	rxlen_t = (rxlen < 496) ? rxlen : 496;
	ptail = recvframe_put(precvframe, rxlen_t); 
	rxlen -= rxlen_t;   

	rxlen_t = (rxlen >> 9) << 9;
	remainder = rxlen - rxlen_t;
	if(remainder) rxlen_t += 512;

	while(rxlen > 0)
	{
              if( rxlen_t > (sint)(pend-ptail) )//?
              {
                   //diag_printf("blk_read_rxpkt-1, rxlen_t=%d, rxlen=%d, pend=%x, ptail=%x, end-tail=%d\n", rxlen_t, rxlen,pend, ptail, (pend-ptail));			               	
             	     DEBUG_ERR(("!!!! Rx pkt's len too large  = %x ;will drop pkt!!!!", rxlen_t));
                   rxlen_t = pend-ptail;
                   read_port(padapter,  Host_R_FIFO, rxlen_t, ptail);	
			
                   //don't update tail;
                   rxlen -= rxlen_t;                    				   
		     ret=_FAIL;
              }
	       else
		{
		     read_port(padapter,  Host_R_FIFO, rxlen_t, ptail);
		    //update tail
		    ptail = recvframe_put(precvframe, rxlen);	
		    rxlen = 0;	
	       }
	}
	
_func_exit_;	

exit:
	return ret;
	
}


u32 byte_read_rxpkt(_adapter *padapter, union recv_frame *precvframe){
	
	sint rxlen, rxlen_t, remainder;
	struct recv_stat *prxstat;
	struct recv_test *prxtest;//
	u32 ret=_SUCCESS;
	u8 *phead=precvframe->u.hdr.rx_head;
	u8 *pdata=precvframe->u.hdr.rx_data;
	u8 *ptail=precvframe->u.hdr.rx_tail;
	u8 *pend=precvframe->u.hdr.rx_end;   
	
_func_enter_;	
       //read 16 bytes rx status
	read_port(padapter, Host_R_FIFO, 16, phead);  
       prxstat=(struct recv_stat *)phead;
	prxtest=(struct recv_test *)phead;
   

#ifdef CONFIG_BIG_ENDIAN
prxstat ->frame_length = prxtest->frame_length1+(prxtest->frame_length2<<8);
prxstat->ack_policy = prxtest->ack_policy;
prxstat->addr_hit = prxtest->addr_hit;
prxstat->agc = prxtest->agc;
prxstat->antenna = prxtest->antenna;
prxstat->cfo = prxtest->cfo;
prxstat->crc32 = prxtest->crc32;
prxstat->data = prxtest->data;
prxstat->decrypted = prxtest->decrypted;
prxstat->eosp = prxtest->eosp;
prxstat->fot = prxtest->fot1+(prxtest->fot2<<8);
prxstat->frag = prxtest->frag;
prxstat->icv = prxtest->icv;
prxstat->k_int = prxtest->k_int;
prxstat->mdata = prxtest->mdata;
prxstat->mgt = prxtest->mgt;
prxstat->no_mcsi = prxtest->no_mcsi1+ (prxtest->no_mcsi2<< 2);
prxstat->own = prxtest->own;
prxstat->pwdb = prxtest->pwdb;
prxstat->pwrmgt = prxtest->pwrmgt;
prxstat->qos = prxtest->qos;
prxstat->queue_size = prxtest->queue_size;
prxstat->retx = prxtest->retx;
prxstat->rssi = prxstat->rssi;
prxstat->rxdata = prxstat->rxdata;
prxstat->rxsnr = prxtest->rxsnr;
prxstat->seq = prxtest->seq1 +(prxtest->seq2<<8);
prxstat->splcp = prxtest->splcp;
prxstat->sq = prxtest->sq;
prxstat->tid = prxtest->tid;
prxstat->txmac_id = prxtest->txmac_id;
#endif


	//get frame length	from rx status
	rxlen = prxstat->frame_length;	
	//diag_printf("byte_read_rxpkt-0, rxlen=%d, pend=%x, ptail=%x, end-tail=%d\n", rxlen,pend, ptail, (pend-ptail));			 
	
		 
	//notes:update tail before update pdata
	ptail = recvframe_put(precvframe, 16);
       pdata = recvframe_pull(precvframe, 16);	
		
	
	//start to rd rxdata
	rxlen_t = (rxlen < 496) ? rxlen : 496;
	read_port(padapter,  Host_R_FIFO, rxlen_t, ptail);

       //update tail
       ptail = recvframe_put(precvframe, rxlen_t);
	rxlen -= rxlen_t;

	while(rxlen > 0)
	{
              if( rxlen > (sint)(pend-ptail) )
              {
                   rxlen_t = pend-ptail;
                   read_port(padapter,  Host_R_FIFO, rxlen_t, ptail);	

                   //don't update tail;		   
                   rxlen -= rxlen_t;                    				   
		     ret=_FAIL;
                   //diag_printf("byte_read_rxpkt-1, rxlen=%d, pend=%x, ptail=%x, end-tail=%d\n", rxlen,pend, ptail, (pend-ptail));			 
              }
	       else
		{
                  //diag_printf("byte_read_rxpkt-2, rxlen=%d, pend=%x, ptail=%x, end-tail=%d\n", rxlen,pend, ptail, (pend-ptail));			  			
		     read_port(padapter,  Host_R_FIFO, rxlen, ptail);
		    //update tail
		    ptail = recvframe_put(precvframe, rxlen);	
                  //diag_printf("byte_read_rxpkt-3, rxlen=%d, pend=%x, ptail=%x, end-tail=%d\n", rxlen,pend, ptail, (pend-ptail));			 
              			
		    rxlen = 0;	
	       }
	}

_func_exit_;	

	return ret;
	
}
#endif

sint	enqueue_recvframe_usb(union recv_frame *precvframe, _queue *queue)
{
//	_irqL irqL;
//	_adapter *padapter=precvframe->u.hdr.adapter;
//	struct recv_priv *precvpriv;

_func_enter_;

	list_delete(&(precvframe->u.hdr.list));
		
	list_insert_tail(&(precvframe->u.hdr.list), get_list_head(queue));

_func_exit_;	
	return _SUCCESS;
}


s32 recv_entry( IN _nic_hdl	cnxt)	
{
	_irqL irqL;
	struct recv_priv *precvpriv;
	_queue *pfree_recv_queue, *ppending_recv_queue;	
	union recv_frame *precvframe;       
	u8 *phead, *pdata, *ptail,*pend;      
	_pkt *precv_ndispkt; 
//	_buffer *pndisbuffer;
#ifdef CONFIG_RTL8187
	struct rx_desc_rtl8187b *prxstat; 
#else
	struct recv_stat *prxstat; 
#endif
	uint  bufferlen;
	s32 ret=_SUCCESS;
	u8 bdrop=_FALSE;	
	_adapter *padapter;//=(_adapter *)netdev_priv(cnxt);       
//	struct	mlme_priv	*pmlmepriv = &padapter->mlmepriv;
	struct intf_hdl * pintfhdl;//=&padapter->pio_queue->intf;

_func_enter_;		

        DEBUG_INFO(("\n ==>recv_entry!!!!!!!!!!!! \n"));	
#ifdef CONFIG_SDIO_HCI
	padapter=(_adapter *)netdev_priv(cnxt);
	pintfhdl=&padapter->pio_queue->intf;
	
#endif
#ifdef	CONFIG_USB_HCI
	precvframe=(union recv_frame *)cnxt;
	padapter=precvframe->u.hdr.adapter;
	pintfhdl=&padapter->pio_queue->intf;
#endif
	precvpriv = &(padapter->recvpriv);


	pfree_recv_queue = &(precvpriv->free_recv_queue);
	ppending_recv_queue = &(precvpriv->recv_pending_queue);

#ifdef CONFIG_SDIO_HCI	
	//dequeue
	precvframe = alloc_recvframe(pfree_recv_queue);	
       if (precvframe == NULL)
       {    
       	DEBUG_INFO(("alloc_recvframe failed!!"));
       	goto _recv_entry_drop;      
       }
	   
	
	//init recv_frame
	init_recvframe(precvframe, precvpriv);    


	if ((registry_par->chip_version >= RTL8711_3rdCUT) || (registry_par->chip_version == RTL8711_FPGA))
	{
		if(pdev->block_mode==1) 
		{
#ifdef RD_BLK_MODE 
			blk_mode = _TRUE;
#endif
		}   
	}   

	if(blk_mode)
		ret=blk_read_rxpkt(padapter, precvframe);
	
	else
		ret=byte_read_rxpkt(padapter, precvframe);

	if((ret==_FAIL) || (ret==state_no_rx_data))
	{
		//diag_printf("recv_entry-1\, ret=%d\n", ret);	
		goto _recv_entry_drop; 

	}

#endif

	
	phead=precvframe->u.hdr.rx_head;
       pdata=precvframe->u.hdr.rx_data;
       ptail=precvframe->u.hdr.rx_tail;
       pend=precvframe->u.hdr.rx_end;  
       precv_ndispkt=precvframe->u.hdr.pkt;  
#ifdef CONFIG_RTL8187      	       	   
	prxstat=(struct rx_desc_rtl8187b *)ptail;
#else
	prxstat=(struct recv_stat *)phead;
#endif
       //update_rxstatus(padapter, precvframe, prxstat );
#ifdef CONFIG_MP_INCLUDED	
       if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)// && 
	   	/*(check_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE) != _TRUE)*/ )	   	
	{
		padapter->mppriv.rx_pktcount++;

		if(prxstat->crc32)
			padapter->mppriv.rx_crcerrpktcount++;

		_memcpy(&padapter->mppriv.rxstat, prxstat, sizeof(struct recv_stat));

		//DEBUG_ERR("mp_mode:recv_entry()\n");		   

		//goto _recv_entry_drop;
       }
	   
#endif	


#if 0
	/* Perry:
		If we receive packet which more = 0, it means we can push driver to sleep mode.
		Also, we must make sure that 
	*/
	if (prxstat->mdata == 0)
		unregister_rx_alive(padapter);
#endif

	if(bdrop==_TRUE)
		goto _recv_entry_drop;

       //remove 4 bytes FCS
       ptail = recvframe_pull_tail(precvframe, 4);	
       bufferlen = ptail -pdata;
	
       //todo: check frame length, get len by using macro
       if(precvframe->u.hdr.len != (prxstat->frame_length-4))
	{
		DEBUG_ERR(("recv_entry:%d, %d\n", precvframe->u.hdr.len, prxstat->frame_length));
		goto _recv_entry_drop;
	}
       //     goto _recv_entry_drop;	   
	//todo:check if ptail > pend 	

	//if ((if_up((unsigned char*)padapter)) == _FALSE)
	//	goto _recv_entry_drop;

       //todo: check if  free_recv_queue is empty after dequeue one 
       //        if yes, enqueue back to  free_recv_queue after read hw rx fifo data, and reuse ndispacket

#ifdef CONFIG_USB_HCI
	_enter_critical(&ppending_recv_queue->lock, &irqL);

	if(_queue_empty(ppending_recv_queue) == _TRUE) {
		//enqueue to recv_pending_queue
		enqueue_recvframe_usb(precvframe, ppending_recv_queue);
#ifdef LINUX_TASKLET
		tasklet_schedule(&padapter->irq_rx_tasklet);
#else
		_up_sema(&precvpriv->recv_sema);
#endif
	}
	else
		//enqueue to recv_pending_queue
		enqueue_recvframe_usb(precvframe, ppending_recv_queue);
	
	_exit_critical(&ppending_recv_queue->lock, &irqL);
	 
	precvpriv->rx_pkts++;
		
_func_exit_;		
	   return ret;
#else
	if(_queue_empty(pfree_recv_queue) == _TRUE )
	{
		//check if precv_frame->u.hdr.pkt == NULL
		if(precv_ndispkt == NULL)
		{
			ret = _FAIL;
			DEBUG_ERR(("recv_indicatepkt():failed to allocate SKB_BUFF\n"));
			goto  _recv_entry_drop;
		}

		//todo:
		DEBUG_ERR(("\n _recv_entry_drop: if(_queue_empty(pfree_recv_queue) == _TRUE)\n"));
		goto  _recv_entry_drop;
	}
	else
	{
		//enqueue to recv_pending_queue
		enqueue_recvframe(precvframe, ppending_recv_queue);

                //todo: _up_sema in caller
		_up_sema(&precvpriv->recv_sema);

		precvpriv->rx_pkts++;
_func_exit_;
		return ret;
	}
#endif

_recv_entry_drop:

#ifdef	CONFIG_USB_HCI
	usb_read_port(pintfhdl, 0, 0, (unsigned char *)precvframe);
#else
	if(precvframe)//enqueue back to  free_recv_queue
		free_recvframe(precvframe, pfree_recv_queue);
#endif

	precvpriv->rx_drop++;	
#ifdef CONFIG_MP_INCLUDED	
	padapter->mppriv.rx_pktloss = precvpriv->rx_drop;
#endif
       DEBUG_ERR(("_recv_entry_drop\n"));
_func_exit_;	
	return ret;

}




sint recv_decache(union recv_frame *precv_frame, u8 bretry, struct stainfo_rxcache *prxcache)
{
	sint tid = precv_frame->u.hdr.attrib.priority;

	u16 seq_ctrl = ( (precv_frame->u.hdr.attrib.seq_num&0xffff) << 4) | 
		(precv_frame->u.hdr.attrib.frag_num & 0xf);

_func_enter_;			
	if(bretry)
	{
		if(seq_ctrl == prxcache->tid_rxseq[tid])
			return _FAIL;
	}

	prxcache->tid_rxseq[tid] = seq_ctrl;
_func_exit_;		
	return _SUCCESS;

}



//
sint sta2sta_data_frame(
	_adapter *adapter, 
	union recv_frame *precv_frame, 
 	struct sta_info**psta
 )
{
	u8 *ptr = precv_frame->u.hdr.rx_data;
	sint ret = _SUCCESS;
	struct rx_pkt_attrib *pattrib = & precv_frame->u.hdr.attrib;
	struct	sta_priv 		*pstapriv = &adapter->stapriv;
//	struct	qos_priv   	*pqospriv= &adapter->qospriv;
//	struct	security_priv	*psecuritypriv = &adapter->securitypriv;
	struct	mlme_priv	*pmlmepriv = &adapter->mlmepriv;
	u8 *mybssid  = get_bssid(pmlmepriv);
	u8 *myhwaddr = myid(&adapter->eeprompriv);
	u8 * sta_addr = NULL;

	sint bmcast = IS_MCAST(pattrib->dst);
	
_func_enter_;		

 	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) ||
		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)) 
	{

           // filter packets that SA is myself or multicast or broadcast
	    if (_memcmp(myhwaddr, pattrib->src, ETH_ALEN)){
		  DEBUG_ERR((" SA==myself \n"));
		  ret= _FAIL;
		  goto exit;
	    }		
        
	    if( (!_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))	&& (!bmcast) ){
		  ret= _FAIL;
		  goto exit;
	    	}  
	    if( _memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
		   _memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
		   (!_memcmp(pattrib->bssid, mybssid, ETH_ALEN)) ) {
			ret= _FAIL;
			goto exit;
	    	}
	    sta_addr = pattrib->src;			
		
	}
	else if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
	{	
	      // For Station mode, sa and bssid should always be BSSID, and DA is my mac-address
		if(!_memcmp(pattrib->bssid, pattrib->src, ETH_ALEN) )
		{
			DEBUG_ERR(("bssid != TA under STATION_MODE; drop pkt\n"));
			ret= _FAIL;
			goto exit;
		}

	       sta_addr = pattrib->bssid;			

	 }
	 else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
	 {
	      	if (bmcast)
		{
			// For AP mode, if DA == MCAST, then BSSID should be also MCAST
			if (!IS_MCAST(pattrib->bssid)){
					ret= _FAIL;
					goto exit;
			}
		}
		else // not mc-frame
		{
			// For AP mode, if DA is non-MCAST, then it must be BSSID, and bssid == BSSID
			if(!_memcmp(pattrib->bssid, pattrib->dst, ETH_ALEN)) {
				ret= _FAIL;
				goto exit;
			}

	       	sta_addr = pattrib->src;			
		
		}
		
	  }
	 else if(check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
	 {
              _memcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);
	       _memcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);
	       _memcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);
  	       _memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
		_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);

              sta_addr = mybssid;	 
	  }
	 else
	 {
	 	ret  = _FAIL;
	 }


	 
	if(bmcast)
		*psta = get_bcmc_stainfo(adapter);
	else
		*psta = get_stainfo(pstapriv, sta_addr); // get ap_info

	if (*psta == NULL) {
	       DEBUG_ERR(("can't get psta under sta2sta_data_frame ; drop pkt\n"));
#ifdef CONFIG_MP_INCLUDED		   
               if(check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
                    adapter->mppriv.rx_pktloss++;   
#endif			   
	       ret= _FAIL;
		   goto exit;
	}			
	 
exit:
_func_exit_;		
	return ret;

}


sint ap2sta_data_frame(
	_adapter *adapter, 
	union recv_frame *precv_frame, 
 	struct sta_info**psta )
{
	u8 *ptr = precv_frame->u.hdr.rx_data;
	struct rx_pkt_attrib *pattrib = & precv_frame->u.hdr.attrib;
	sint ret = _SUCCESS;
	struct	sta_priv 		*pstapriv = &adapter->stapriv;
//	struct	qos_priv   	*pqospriv= &adapter->qospriv;
//	struct	security_priv	*psecuritypriv = &adapter->securitypriv;
	struct	mlme_priv	*pmlmepriv = &adapter->mlmepriv;

	u8 *mybssid  = get_bssid(pmlmepriv);
	u8 *myhwaddr = myid(&adapter->eeprompriv);
	
	sint bmcast = IS_MCAST(pattrib->dst);

_func_enter_;	

	if ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE) && 
		(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) )
	{
	
	       // if NULL-frame
	      if ((GetFrameSubType(ptr)) == WIFI_DATA_NULL)
	      {
		   	DEBUG_INFO((" NULL frame \n"));	
			ret= _FAIL;
			goto exit;
	           
	       }
		   
              // filter packets that SA is myself or multicast or broadcast
	       if (_memcmp(myhwaddr, pattrib->src, ETH_ALEN)){
		     DEBUG_ERR((" SA==myself \n"));
			ret= _FAIL;
			goto exit;
		}	

		// da should be for me  
              if((!_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))&& (!bmcast))
              {
                  DEBUG_INFO((" ap2sta_data_frame:  compare DA fail; DA= %x:%x:%x:%x:%x:%x \n",
					pattrib->dst[0],
					pattrib->dst[1],
					pattrib->dst[2],
					pattrib->dst[3],
					pattrib->dst[4],
					pattrib->dst[5]));
				   
				ret= _FAIL;
				goto exit;
              }
			  
		
		// check BSSID
		if( _memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
		     _memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
		     (!_memcmp(pattrib->bssid, mybssid, ETH_ALEN)) )
		{
                    DEBUG_INFO((" ap2sta_data_frame:  compare BSSID fail ; BSSID=%x:%x:%x:%x:%x:%x\n",
				pattrib->bssid[0],
				pattrib->bssid[1],
				pattrib->bssid[2],
				pattrib->bssid[3],
				pattrib->bssid[4],
				pattrib->bssid[5]));
				
			DEBUG_INFO(("mybssid= %x:%x:%x:%x:%x:%x\n", 
				mybssid[0],
				mybssid[1],
				mybssid[2],
				mybssid[3],
				mybssid[4],
				mybssid[5]));
                   
			ret= _FAIL;
			goto exit;
			}	

		if(bmcast)
			*psta = get_bcmc_stainfo(adapter);
		else
		       *psta = get_stainfo(pstapriv, pattrib->bssid); // get ap_info

		if (*psta == NULL) {
			DEBUG_ERR(("ap2sta: can't get psta under STATION_MODE ; drop pkt\n"));
			ret= _FAIL;
			goto exit;
		}

	}
       else if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE) && 
		     (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) )
	{      
	       _memcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);
	       _memcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);
	       _memcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);
  	       _memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
		_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);

		//
		_memcpy(pattrib->bssid,  mybssid, ETH_ALEN);
		  
		  
		   *psta = get_stainfo(pstapriv, pattrib->bssid); // get sta_info
		if (*psta == NULL) {
		       DEBUG_ERR(("can't get psta under MP_MODE ; drop pkt\n"));
			ret= _FAIL;
			goto exit;
		}

	
	}
	else
	{
		ret =  _FAIL;
	}
exit:	
_func_exit_;	
	return ret;

}




sint sta2ap_data_frame(
	_adapter *adapter, 
	union recv_frame *precv_frame, 
 	struct sta_info**psta )
{
//	u8 *ptr = precv_frame->u.hdr.rx_data;
	struct rx_pkt_attrib *pattrib = & precv_frame->u.hdr.attrib;
	struct	sta_priv 		*pstapriv = &adapter->stapriv;
//	struct	qos_priv   	*pqospriv= &adapter->qospriv;
//	struct	security_priv	*psecuritypriv = &adapter->securitypriv;
	struct	mlme_priv	*pmlmepriv = &adapter->mlmepriv;

	unsigned char *mybssid  = get_bssid(pmlmepriv);
//	unsigned char *myhwaddr = myid(&adapter->eeprompriv);
	sint ret=_SUCCESS;
	sint bmcast = IS_MCAST(pattrib->dst);

_func_enter_;


	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
	{ 

		if (bmcast)
		{
			// For AP mode, if DA == MCAST, then BSSID should be also MCAST
			//bssid = mc-addr => psta=NULL
			if (!IS_MCAST(pattrib->bssid)){
				ret= _FAIL;
				goto exit;
			}
			*psta = get_bcmc_stainfo(adapter);
			
		}
		else // not mc-frame

		{
		
			// For AP mode, if DA is non-MCAST, then it must be BSSID, and bssid == BSSID
			if( (!_memcmp(mybssid, pattrib->dst, ETH_ALEN)) || 
				(!_memcmp(pattrib->bssid, mybssid, ETH_ALEN)) ){
					ret= _FAIL;
					goto exit;
				}

			*psta = get_stainfo(pstapriv, pattrib->src);

			if (*psta == NULL)
			{
				DEBUG_ERR(("can't get psta under AP_MODE; drop pkt\n"));
				ret= _FAIL;
				goto exit;
			}
			
		}

	}
exit:
_func_exit_;	
	return ret;

}

sint validate_recv_ctrl_frame(_adapter *adapter, union recv_frame *precv_frame)
{
	mgtctrl_dispatchers(adapter,precv_frame);
	return _FAIL;
}

sint validate_recv_mgnt_frame(_adapter *adapter, union recv_frame *precv_frame)
{
	DEBUG_INFO(("\n validate_recv_mgnt_frame\n"));
	mgtctrl_dispatchers(adapter,precv_frame);
	return _FAIL;
}


sint validate_recv_data_frame(_adapter *adapter, union recv_frame *precv_frame)
{


	int res;	
	u8 bretry;
	u8	*psa, *pda, *pbssid;
	struct	sta_info	*psta = NULL;
	
	u8 *ptr = precv_frame->u.hdr.rx_data;
//	uint	frtype = GetFrameType(ptr);
//	u8 *myhwaddr = myid(&adapter->eeprompriv);

	struct	rx_pkt_attrib	*pattrib = & precv_frame->u.hdr.attrib;
//	struct	sta_priv 		*pstapriv = &adapter->stapriv;
//	struct	qos_priv   	*pqospriv= &adapter->qospriv;
	struct	security_priv	*psecuritypriv = &adapter->securitypriv;
	struct	mlme_priv	*pmlmepriv = &adapter->mlmepriv;
#ifdef CONFIG_RTL8187
	struct rx_desc_rtl8187b * prxcmd = (struct rx_desc_rtl8187b *)(precv_frame->u.hdr.rx_tail+4);
#else
	struct recv_stat *	prxcmd = (struct recv_stat *)(get_rxmem(precv_frame));
#endif

	NDIS_WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
	sint	ret=_SUCCESS;
_func_enter_;	
	bretry = GetRetry(ptr);
	pda = get_da(ptr);
	psa = get_sa(ptr);
	pbssid = get_hdr_bssid(ptr);

	if(pbssid == NULL){
		ret= _FAIL;
		goto exit;
	}

	_memcpy(pattrib->dst, pda, ETH_ALEN);
	_memcpy(pattrib->src, psa, ETH_ALEN);
	_memcpy(pattrib->bssid, pbssid, ETH_ALEN);

	switch(pattrib->to_fr_ds)
	{
		case 0:
			_memcpy(pattrib->ra, pda, ETH_ALEN);
			_memcpy(pattrib->ta, psa, ETH_ALEN);
			res= sta2sta_data_frame(adapter, precv_frame, &psta);
			break;

		case 1:	
			_memcpy(pattrib->ra, pda, ETH_ALEN);
			_memcpy(pattrib->ta, pbssid, ETH_ALEN);
			res= ap2sta_data_frame(adapter, precv_frame, &psta);
			break;

		case 2:
			_memcpy(pattrib->ra, pbssid, ETH_ALEN);
			_memcpy(pattrib->ta, psa, ETH_ALEN);
			res= sta2ap_data_frame(adapter, precv_frame, &psta);
			break;
		
		case 3:	
			_memcpy(pattrib->ra, GetAddr1Ptr(ptr), ETH_ALEN);
			_memcpy(pattrib->ta, GetAddr2Ptr(ptr), ETH_ALEN);
                     res=_FAIL;
			DEBUG_ERR((" case 3\n"));
			break;		
		default:
			res=_FAIL;			
			break;			

	}

	if(res==_FAIL){
		DEBUG_INFO((" after to_fr_ds_chk; res = fail \n"));
		ret= res;
	}	

	if(psta==NULL){
		DEBUG_INFO((" after to_fr_ds_chk; psta==NULL \n"));
		ret= _FAIL;
		goto exit;
	}

	//update RSSI & Signal Quality ; 20061102 yitsen
	psta->rssi = prxcmd->rssi;
	psta->signal_quality= prxcmd->sq;
	
	if(pcur_bss!=NULL){
		pcur_bss->Rssi =  	prxcmd->rssi;
	}


	// parsing QC field
	if(pattrib->qos == 1)
	{
		pattrib->priority = GetPriority((ptr + 24));
		pattrib->ack_policy =GetAckpolicy((ptr + 24));
		pattrib->hdrlen = pattrib->to_fr_ds==3 ? 32 : 26;
	}
	else
		pattrib->hdrlen = pattrib->to_fr_ds==3 ? 30 : 24;
	


	// decache

	if(recv_decache(precv_frame, bretry, &psta->sta_recvpriv.rxcache) == _FAIL)
	{
		DEBUG_INFO(("decache : drop pkt\n"));
		ret= _FAIL;
		goto exit;
	}

	if(pattrib->privacy){
		DEBUG_INFO(("validate_recv_data_frame:pattrib->privicy=%x\n",pattrib->privacy));
		GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt,IS_MCAST(pattrib->ra));
		SET_ICE_IV_LEN(pattrib->iv_len, pattrib->icv_len, pattrib->encrypt);
	}
	else
	{
		pattrib->encrypt = 0;
		pattrib->iv_len = pattrib->icv_len = 0;
	}
		
exit:
_func_exit_;
	return ret;

}



sint validate_recv_frame(_adapter *adapter, union recv_frame *precv_frame)
{
	//shall check frame subtype, to / from ds, da, bssid
	
	//then call check if rx seq/frag. duplicated.

	u8 type;
	u8 subtype;
	sint retval = _SUCCESS;
	
	struct rx_pkt_attrib *pattrib = & precv_frame->u.hdr.attrib;
	
	u8 *ptr = precv_frame->u.hdr.rx_data;
	u8  ver =(unsigned char) (*ptr)&0x3 ;

_func_enter_;
	//add version chk

	if(ver!=0){
		retval= _FAIL;
		goto exit;
	}
	type =  GetFrameType(ptr);
	subtype = GetFrameSubType(ptr); //bit(7)~bit(2)

	pattrib->to_fr_ds = get_tofr_ds(ptr);
	 
	pattrib->frag_num = GetFragNum(ptr);
	pattrib->seq_num = GetSequence(ptr);

	pattrib->pw_save = GetPwrMgt(ptr);
	pattrib->mfrag = GetMFrag(ptr);
	pattrib->mdata = GetMData(ptr);	
	pattrib->privacy =  GetPrivacy(ptr);
	
	switch(type)
	{
		case WIFI_MGT_TYPE: //mgnt
		//	printk("@@@@ this is mgnt recv frame @@@@\n");
			if((adapter->mlmepriv.fw_state & _FW_LINKED)==_FALSE)
				retval=validate_recv_mgnt_frame(adapter, precv_frame);
			break;
		case WIFI_CTRL_TYPE://ctrl
		//	printk("@@@@ this is ctrl recv frame @@@@\n");
			retval=validate_recv_ctrl_frame(adapter, precv_frame);
			break;
		case WIFI_DATA_TYPE: //data
			pattrib->qos = (subtype & BIT(7))? 1:0;
			retval=validate_recv_data_frame(adapter, precv_frame);
			break;
		default:
			retval=_FAIL;
			break;
			
	}
exit:
_func_exit_;	
	return retval;

}
void recv_indicatepkt(_adapter *padapter, union recv_frame *precv_frame)
{
//	_irqL	irqL;
       struct recv_priv *precvpriv;
       _queue	*pfree_recv_queue;		
       unsigned char *pdata;      
	unsigned int bufferlen;
	_pkt *skb;

	NDIS_STATUS	 status=0;

_func_enter_;
	precvpriv = &(padapter->recvpriv);	
	pfree_recv_queue = &(precvpriv->free_recv_queue);	
       pdata=get_recvframe_data(precv_frame);	
	bufferlen=precv_frame->u.hdr.len;
	skb=precv_frame->u.hdr.pkt;	

        //check if precv_frame->u.hdr.pkt == NULL
       if(skb == NULL)
       {
            status=1 ;
            DEBUG_ERR(("recv_indicatepkt():skb==NULL something wrong!!!!\n"));		   
	    goto _recv_indicatepkt_drop;
	}
	DEBUG_INFO(("recv_indicatepkt():skb != NULL !!!\n"));		
	DEBUG_INFO(("\n recv_indicatepkt():precv_frame->u.hdr.rx_head=%p  precv_frame->hdr.rx_data=%p ",precv_frame->u.hdr.rx_head,precv_frame->u.hdr.rx_data));
	DEBUG_INFO(("precv_frame->hdr.rx_tail=%p precv_frame->u.hdr.rx_end=%p precv_frame->hdr.len=%d \n",precv_frame->u.hdr.rx_tail,precv_frame->u.hdr.rx_end,precv_frame->u.hdr.len));
	skb->head=precv_frame->u.hdr.rx_head;
	skb->data=precv_frame->u.hdr.rx_data;
	skb->tail=precv_frame->u.hdr.rx_tail;
	skb->end=precv_frame->u.hdr.rx_end;
	skb->len=precv_frame->u.hdr.len;
	DEBUG_INFO(("\n skb->head=%p skb->data=%p skb->tail=%p skb->end=%p skb->len=%d\n",skb->head,skb->data,skb->tail,skb->end,skb->len));
	skb->ip_summed = CHECKSUM_NONE;
	skb->dev=padapter->pnetdev;
	skb->protocol= eth_type_trans(skb, padapter->pnetdev);
	if(skb!= NULL)
	        netif_rx(skb);
	else
		DEBUG_ERR(("\n recv_indicatepkt:doesn't call netif_rx(skb), beacuse skb==NULL!!!!!!!!!!\n"));

//	padapter->last_rx = jiffies;

	precv_frame->u.hdr.pkt=NULL; 
#if 0
	 _enter_critical(&precvpriv->lock, &irqL);
		precvpriv->counter++;
	 _exit_critical(&precvpriv->lock, &irqL);    

	free_recvframe(precv_frame, pfree_recv_queue);
#endif
	DEBUG_INFO(("\n recv_indicatepkt :after netif_rx!!!!\n"));
_func_exit_;		
        return;		

_recv_indicatepkt_drop:
#if 0
	 //todo: enqueue back to free_recv_queue	
	 if(precv_frame)
		 free_recvframe(precv_frame, pfree_recv_queue);
#endif
	 
 	 precvpriv->rx_drop++;	
_func_exit_;
}


